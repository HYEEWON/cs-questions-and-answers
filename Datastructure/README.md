# Data Structure

<br>

## Table of Contents

* [배열 (Array)](#배열-array)
* [리스트 (Sequence)](#리스트-sequence)
* [배열 리스트 (Array List)](#배열-리스트-array-list)
* [연결 리스트 (Linked List)](#연결-리스트-linked-list)
* [해시 테이블](#해시-테이블)
  * [해시 충돌](#해시-충돌)
* [Stack과 Queue](#stack과-queue)
* [Tree](#tree)
* [힙](#힙)
* [Binary Search Tree](#binary-search-tree)
* [그래프 (Graph)](#그래프-graph)
* [Graph를 구현하는 두 가지 방법과 장점](#graph를-구현하는-두-가지-방법과-장점)

<br>

## 👉 비교
* 배열 vs 리스트
* 배열 vs 링크드 리스트
* 배열 리스트 vs 링크드 리스트

<br>

## 배열 (Array)

* 순차적으로 데이터를 저장하는 자료구조
* `메모리 상에 연속적으로 할당한` 자료구조 -> Cache Locality가 좋아 Cache Hit 가능성이 큼
* 조회 성능이 좋고, 삽입/삭제 성능은 나쁨 -> `탐색에서 O(1)`, `삽입/삭제에서 O(N)`
* `크기 고정적` (선언 시 지정한 크기 변경 불가)

<br>

## 리스트 (Sequence)

* 순서가 있는 자료구조 (배열 리스트, 연결 리스트)
* `메모리가 연속적이지 않고` 다음 노드를 가리키는 주소인 `포인터`를 통해 접근하는 자료구조 -> Spacial Locality가 보장되지 않아 Cash Hit 어려움
* 조회 성능이 나쁘고, 삽입/삭제 성능은 좋음
* `크기 가변적`

<br>

## 배열 리스트 (Array List)

* 내부적으로는 배열을 활용하는 자료구조, `메모리가 연속적`으로 배치
* `탐색에서 O(1)`, `삽입/삭제에서 O(N)`
*  삽입/삭제가 많은 경우 좋지않음 -> 삽입/삭제 시에 새로운 메모리 할당/메모리 공간 낭비 발생
* `무작위 접근`: 인덱스로 접근
* 크기에 제한이 있어 재조정에는 많은 연산 필요
* 캐시의 특성(`Locality`) 때문에 빈번한 삽입 삭제가 나지 않는 경우라면 배열 리스트를 사용할 때 일반적으로 성능이 더 좋음

<br>

## 연결 리스트 (Linked List)

* `따로 할당하고 이은` 자료구조, 자료의 주소값으로 서로 연결, `메모리가 불연속적`으로 배치
* `탐색에서 O(N)`, `삽입/삭제에서 O(1)`
* 삽입/삭제 연산이 빠름 -> 주소의 연결만 바꾸면 됨
* `순차 접근`: 무작위 접근은 불가능
* 리스트의 크기와 상관 없이 데이터 추가 가능
* 삽입/삭제가 적다면 연결리스트를 사용하는 것이 좋음
* 포인터 사용으로 인한 메모리 낭비가 있음

<br>

## 해시 테이블

* `Key와 Value`로 데이터를 저장하는 자료구조
* `해시 함수`를 구현하여 데이터를 `해시 값`으로 매핑
* 데이터를 효율적으로 관리하기 위해, 임의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 것
* 배열과 리스트의 장점을 합친 자료구조로 `key 값`을 통해 해시 주소를 알아내어 평균적으로 탐색에 `O(1)`을 보장하는 자료구조

### 👉 해시 충돌

* 서로 다른 key가 같은 해시 값으로 변경되는 것
* 같은 해시 값에 대해 데이터를 조회해 최대 `O(N)` 가능
* `체이닝`: 추가 메모리를 사용해 버킷에 데이터를 `연결 리스트`로 관리
* `개방 주소법`: 기존의 비어있는 버킷의 공간을 활용
  * 선형 조사법(Linear Probing): 현재 버킷의 인덱스에서 `고정 폭`씩 이동하며 데이터를 버킷에 저장
  * 이차 조사법(Quadratic Probing): 현재 버킷의 인덱스에서 `k^2`(k=1, 2, ..)씩 이동하며 데이터를 버킷에 저장
  * 이중 해싱(Double Hashing Probing): 해싱된 값을 한번 더 해싱 -> 연산 증가
* 그럼에도 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해져서 사용함

<br>

## Stack과 Queue
### (1) Stack
* LIFO 방식으로 삽입되고 제거되는 최근성에 포커싱된 자료구조
* Array로 구현하는 것이 좋음
### (2) Queue
* FIFO 방식으로 삽입되고 제거되는 순차성에 포커싱된 자료구조
* Linked List로 구현하는 것이 좋음

## Tree
* 트리는 `사이클을 가지지 않는 그래프`로 부모 자식 관계를 갖는 노드들의 집합으로 `계층적` 구조를 갖는 자료구조
* `이진 트리(Binary Tree)`: 최대 2개의 자식 노드들만 가질 수 있는 트리
* `포화 이진 트리(Perfect Binary Tree)`: 각 레벨에 노드가 꽉 차있는 트리
* `완전 이진 트리(Complete Binary Tree)`: 높이가 K인 트리에서 레벨 1~ 레벨 K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리
* `이진 탐색 트리(Binary Search Tree)`: 탐색을 위해 만들어진 자료구조로 `부모 노드의 키 값이 왼쪽 자식 노드의 키값보다 크고 오른쪽 자식 노드의 키값보다 작은 구조`

## 힙
* 힙은 `완전 이진 트리`의 일종으로 `우선 순위 큐`를 구현하기 위해 만들어진 자료구조인데 이진 탐색 트리가 전체 노드를 탐색하기 위한 자료구조라면 힙은 `최소값 또는 최대값`을 쉽게 뽑아내기 위한 자료구조
* `부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰/작은 완전 이진 트리`로 힙은 자식 노드에도 구분 조건이 필요한 이진 탐색 트리보다 느슨한 정렬 상태를 유지
* 힙 트리는 중복된 값 허용 (이진 탐색 트리는 중복값 허용X)
* 최대 힙(max heap)
  * `부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은` 완전 이진 트리
  * 부모가 최대값
* 최소 힙(min heap)
  * `부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은` 완전 이진 트리
  * 부모가 최소값
* 힙의 삽입
  * `O(logn)`
  * 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입
  * 새로운 노드를 부모 노드들과 교환
* 힙의 삭제
  * `O(logn)`
  * 최대 힙에서 최대값은 루트 노드이므로 루트 노드가 삭제됨 (최대 힙에서 삭제 연산은 최대값 요소를 삭제하는 것)
  * 삭제된 루트 노드에는 힙의 마지막 노드를 가져옴
  * 힙을 재구성

## Binary Search Tree
* 부모보다 작은 값은 왼쪽 자식, 큰 값은 오른쪽 자식. 검색시 내려가면서 해당 노드보다 찾는값이 더 작으면 왼쪽에서 찾고, 찾는값이 더 크면 오른쪽에서 찾는다.
* 노드의 `왼쪽 서브트리에는 그 노드의 값보다 작은 값들`을 지닌 노드들로 이루어져 있다. 노드의 `오른쪽 서브트리에는 그 노드의 값보다 큰 값들`을 지닌 노드들로 이루어져 있다.
* 이진탐색 + 연결리스트
  * 이진탐색 : `탐색에 소요되는 시간복잡도는 O(logN)`, but `삽입,삭제가 불가능`
  * 연결리스트 : `삽입, 삭제의 시간복잡도는 O(1)`, but `탐색하는 시간복잡도가 O(N)`
* 밸런싱이 된 BST는 `O(logN)`이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
  * 삽입, 검색, 삭제 시간복잡도는 `트리의 Depth에 비례`
* 최악의 경우를 방지하는 방법: 자가 균형 트리(Balanced Tree)
  * `AVL 트리`: 왼쪽과 오른쪽 자식의 높이 차이가 1이하일 것을 요구, 삭제/추가 시에 재정렬을 통해 높이를 일정하게 유지, 레드 블랙 트리보다 엄격
  * `레드 블랙 트리`: 모든 노드가 빨강 또는 검정의 색을 갖는 트리로 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없음, 삭제/추가 시에 재정렬과 색깔 재배치를 통해 규칙을 유지
* 삭제
  * 자식이 없는 leaf 노드일 때 : 그냥 삭제
  * 자식이 1개인 노드일 때 : 지워진 노드에 자식노드로 대체하고 지워진 노드의 부모노드와 연결
  * 자식이 2개인 노드일 때 : 오른쪽 서브트리에서 가장 작은 값 or 왼쪽 서브트리에서 가장 큰 값으로 대체

## 그래프 (Graph)
* 정점과 간선으로 이루어진 자료구조

## Graph를 구현하는 두 가지 방법과 장단점
* `인접 행렬`을 사용하는 방법: 2차원 배열을 사용해 정점들의 연결관계를 파악하는 방법으로, 시간 복잡도 `O(1)`로 연결 관계를 파악할 수 있음, `정점과 엣지가 많을 경우 사용`, 구현 간편, 공간 낭비
* `인접 리스트`를 사용하는 방법: 각 정점의 adjacent list를 통해서 연결 관계를 파악하는 방법으로, 정점들의 관계를 `O(정점에 연결된 노드의 수)`로 파악하는 방법, `정점과 엣지가 적을 경우 사용`, 공간 낭비 적음, 탐색 시간이 느림, 구현 어려움
